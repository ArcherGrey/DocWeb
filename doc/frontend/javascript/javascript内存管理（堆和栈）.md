# javascript内存管理（堆和栈）

## 内存基本概念

内存的生命周期：

1. 分配所需的内存
2. 内存的读与写
3. 不需要时将其释放

所有语言的内存生命周期都基本一致，不同的是最后一步在低级语言中很清晰，但是在像 `JavaScript` 等高级语言中，这一步是隐藏的、透明的。

js的内存生命周期：

1. 定义变量时就完成了内存分配
2. 使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数
3. 而内存的释放而依赖GC机制（高级语言解释器嵌入的“垃圾回收器”）

程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做栈（`stack`），另一种叫做堆（`heap`）。

---

## `JavaScript` 的内存分配

### 值的初始化

为了不让程序员费心分配内存，`JavaScript` 在定义变量时就完成了内存分配:
```
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存

var o = {
  a: 1,
  b: null
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "abra"]; 

function f(a){
  return a + 2;
} // 给函数（可调用的对象）分配内存

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

### 通过函数调用分配内存

有些函数调用结果是分配对象内存：
```
var d = new Date(); // 分配一个 Date 对象

var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：
```
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2); 
// 新数组有四个元素，是 a 连接 a2 的结果
```

### 使用值

使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。


### 当内存不再需要使用时释放

大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。

高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。

垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个`Javascript`对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 `JavaScript` 对象，还包括函数作用域（或者全局词法作用域）

---

## 堆（`heap`）与栈（`stack`）

- `heap`是没有结构的，数据可以任意存放。`heap`用于复杂数据类型（引用类型）分配空间，例如数组对象、`object`对象
- `stack`是有结构的，每个区块按照一定次序存放（后进先出），`stack`中主要存放一些基本类型的变量和对象的引用，存在栈中的数据大小与生存期必须是确定的。可以明确知道每个区块的大小，因此，`stack`的寻址速度要快于`heap`

函数调用形成了一个栈帧:
```
function foo(b) {
  var a = 10;
  return a + b + 11;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}

console.log(bar(7));
```

1. 当调用`bar`时，创建了第一个帧 ，帧中包含了`bar`的参数和局部变量
2. 当`bar`调用`foo`时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了`foo`的参数和局部变量。当`foo`返回时，最上层的帧就被弹出栈（剩下`bar`函数的调用帧 ）
3. 当`bar`返回的时候，栈就空了

### 堆与栈的大小

程序运行时，每个线程分配一个`stack`，每个进程分配一个`heap`，也就是说，`stack`是线程独占的，`heap`是线程共用的。此外，`stack`创建的时候，大小是确定的，数据超过这个大小，就发生`stack overflow`错误，而`heap`的大小是不确定的，需要的话可以不断增加。所以这里只看`stack`的大小限制。下面是一个简单的测试：
```
var i=0;
function inc() {
    i++;
    if(i>41909){return;}
    inc();
}
inc();
```

测试环境是`16G`内存的电脑，需要注意的是：根据栈的定义可以知道如果 `inc` 函数里有变量申明的话也是会有内存占用的。
1. 谷歌浏览器`chrome 55.0`版本下限制是41909条
2. IE8浏览器下限制是3062条



### `stack overflow`（栈溢出）

因为`stack`是有限制的，而且`stack`超出浏览器的规定的栈限制时就会报`stack overflow`。一般情况下不会出现这种情况，因为`js`语言有他自己的`GC`机制，而出现这种情况一般是`js`的死循环或者没有正确的停止递归造成的，可以通过调试去追踪`stack`。

---

## `javascript` 的单线程 

`JavaScript`语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。

`JavaScript`的单线程，与它的用途有关。作为浏览器脚本语言，`JavaScript`的主要用途是与用户互动，以及操作`DOM`。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定`JavaScript`同时有两个线程，一个线程在某个`DOM`节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免复杂性，从一诞生，`JavaScript`就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核`CPU`的计算能力，`HTML5`提出`Web Worker`标准，允许`JavaScript`脚本创建多个线程，但是子线程完全受主线程控制，且不得操作`DOM`。所以，这个新标准并没有改变`JavaScript`单线程的本质。

### `Event-Loop`（事件循环）

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

如果排队是因为计算量大，`CPU`忙不过来，倒也算了，但是很多时候`CPU`是闲着的，因为`IO`设备（输入输出设备）很慢（比如`Ajax`操作从网络读取数据），不得不等着结果出来，再往下执行。

`JavaScript`语言的设计者意识到，这时主线程完全可以不管`IO`设备，挂起处于等待中的任务，先运行排在后面的任务。等到`IO`设备返回了结果，再回过头，把挂起的任务继续执行下去。

于是，所有任务可以分成两种，一种是同步任务（`synchronous`），另一种是异步任务（`asynchronous`）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（`task queue`）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

常见的异步任务有`Ajax`操作、定时器（`setTimeout/setInterval`）、`UI`事件（`load`(图片`js`文件的加载等)、`resize`、`scroll`、`click`等）。

具体来说，异步执行的运行机制如下（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：
1. 所有同步任务都在主线程上执行，形成一个执行栈（`execution context stack`）。
2. 主线程之外，还存在一个"任务队列"（`task queue`）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复上面的第三步。