# 目录
- [加载和运行](#加载和运行)
- [数据访问](#数据访问)
- [DOM编程](#文档对象模型编程)
- [算法和流程控制](#算法和流程控制)
- [字符串和正则表达式](#字符串和正则表达式)
- [响应接口](#响应接口)
- [ajax和xml](#ajax/xml)
- [编程实践](https://github.com/ArcherGrey/study/blob/master/JavaScript/HPjavascript/HPjavascript8.md)

# 加载和运行

`<script>` 标签使得整个页面因为脚本解析、运行而出现等待，无论是内联还是包含在外边文件中的 javascript 代码，在`页面下载`和`解析过程`的时候都会使页面阻塞等待这些处理完成才能继续。

因为无法预知javascript是否会对页面进行修改，所以浏览器会停下来运行javascript然后继续解析翻译页面。这个过程中，页面解析和用户交互式被完全阻塞的。

## 脚本位置

`问题`：浏览器在遇到 `<body>` 标签的时候才会开始渲染，如果将脚本文件放在之前那么将会先下载运行脚本文件再进行渲染，这样做会使得其他页面资源被阻塞，也就是网页开始加载时用户必须等待一段空白页面直到脚本下载并且运行完成。

`解决`：推荐的办法是尽量将脚本文件放在 `<body>` 标签的底部位置，尽量减少对整个页面下载的影响。 

> 将脚本放在底部

## 脚本数量

`问题`：每个 `<script>` 标签下载时都会阻塞页面解析过程，下载一个100KB的文件比四个25KB的文件要快。（因为每个文件的下载都是http请求，文件数量多了请求数量也就多了）
`解决`：将多个脚本文件整个成一个文件，只使用一个标签引用，可以通过打包工具实现。

> 脚本文件越少越好

## 非阻塞脚本

`问题`：保持脚本文件短小，限制http请求数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多所需要的javascript代码就越多，保持源码短小并不是总能实现。尽管下载一个大的javascript文件只产生一次请求，却会锁定浏览器一大段时间，为了解决这个问题我们需要向页面中逐步添加javascript，同时不阻塞浏览器。

`解决`：非阻塞脚本的秘密在于，等页面完成加载之后，再加载javascript。也就是说在页面 load 事件完成之后开始下载代码。

主要有下面几种方式实现：
- 延期脚本：html4 为 `<script>` 标签定义了一个扩展属性 `defer`。这个属性指明所包含的脚本不会修改DOM，因此代码可以稍后执行。这个方法需要 `Internet Explorer 4` 和 `Firefox 3.5` 更高版本的浏览器支持，如果浏览器支持的话，是一种可行的解决方案。带有扩展属性 `defer`的标签可以放在文档的任何位置。（经测试chrome不支持）

例子：(如果浏览器支持就会依次弹出“script”，“defer”和“load”，不支持会是“defer”，“script”和“load”)
```
<html>
<head>
<title>Script Defer Example</title>
</head>
<body>
<script defer>
alert("defer");
</script>
<script>
alert("script");
</script>
<script>
window.onload = function(){
alert("load");
};
</script>
</body>
</html>
```
<hr>

- 动态脚本节点（dynamic script node）：DOM允许你是用javascript动态创建几乎全部文档内容，`<script>` 和其他页面元素没有什么不同，所以可以使用DOM来动态加载javascript文件，这样加载代码使得代码的下载和运行都不会阻塞其他页面处理过程，而且还可以把动态加载的脚本放在页面的任何位置而不会对其余部分的页面代码造成影响。这种方法就能在页面中动态加载很多javascript文件，是非阻塞下载中最常用的模式，因为它可以跨浏览器同时简单易用。

例子：
```
var script = document.createElement ("script");
script.type = "text/javascript";
script.src = "file1.js";
document.getElementsByTagName_r("head")[0].appendChild(script);
```
<hr>

- XHR 脚本注入：这种方法首先创建一个XHR对象然后下载javascript文件，接着使用上面动态脚本加载的方法将代码注入页面。

例子：
```
var xhr = new XMLHttpRequest();
xhr.open("get", "file1.js", true);
xhr.onreadystatechange = function(){
if (xhr.readyState == 4){
if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304){
var script = document.createElement ("script");
script.type = "text/javascript";
script.text = xhr.responseText;
document.body.appendChild(script);
}
}
};
xhr.send(null);
```
此代码向服务器发送一个获取file1.js 文件的GET 请求。onreadystatechange 事件处理函数检查readyState是不是4，然后检查HTTP 状态码是不是有效（2XX 表示有效的回应，304 表示一个缓存响应）。如果收到了一个有效的响应，那么就创建一个新的<script>元素，将它的文本属性设置为从服务器接收到的responseText 字符串。这样做实际上会创建一个带有内联代码的<script>元素。一旦新<script>元素被添加到文档，代码将被执行，并准备使用。
  
这种方法的主要优点是，你可以下载javascript代码而不立即执行。由于代码返回在标签之外，所以下载后不会自动执行，可以人为控制执行时机。

不过这个方法有个限制：javascript文件必须与页面放置在同一个域内，正因为这个原因，大型网页通常不使用该技术。

## 推荐的非阻塞模式
 
推荐的向页面加载大量javascript的方法有两个步骤：
1. 包含动态加载javascript所需的代码
2. 然后加载页面初始化所需的除了javascript之外的部分

这部分代码尽量小，可能只包含loadscript()函数，它的下载和运行非常迅速，不会对页面造成很大的干扰。当初始代码准备好之后，用它来加载其余的javascript。例子：
```
<script type="text/javascript" src="loader.js"></script>
<script type="text/javascript">
loadScript("the-rest.js", function(){
Application.init();
});
</script>
```
将此段代码放在 `</body>` 之前。这样做有几点好处：
1. javascript的运行不会影响页面的其他部分显示
2. 当javascript文件完成下载所有的DOM都已经创建完成，并且做好被访问的准备，避免再使用额外的事件处理（例如 window.onload）来得知页面是否已经准备好了

另一个选择是直接将 loadScript() 函数嵌入在页面中，这样可以避免另一次http请求。例如：
```
<script type="text/javascript">
function loadScript(url, callback){
var script = document.createElement ("script")
script.type = "text/javascript";
if (script.readyState){ //IE
script.onreadystatechange = function(){
if (script.readyState == "loaded" ||
script.readyState == "complete"){
script.onreadystatechange = null;
callback();
}
};
} else { //Others
script.onload = function(){
callback();
};
}
script.src = url;
document.getElementsByTagName_r("head")[0].appendChild(script);
}
loadScript("the-rest.js", function(){
Application.init();
});
</script>
```

一旦页面初始化下载完成，还可以使用loadscript()函数来加载页面所需的额外功能函数。

## 总结

javascript代码的执行和下载会阻塞浏览器的进程，减少javascript对性能的影响主要方法：
- 将所有 <script> 标签放置在页面的底部，body的底部，保证页面加载完成之前不会受到javascript脚本执行或下载的影响
- 将脚本打包，减少脚本数量，脚本越少加载越快，页面的响应越迅速，无论是内联还是外部脚本都是如此
- 使用非阻塞方式下载javascript：1.添加defer属性（对浏览器版本有要求）2.动态创建脚本 3.使用xhr对象下载脚本，并注入到页面中

对于大量使用javascript代码的网页上述方法可以极大提供网页应用的实际性能。

---

# 数据访问

数据存储在哪里，关系到代码运行期间数据被检索到的速度。在javascript中这个问题相对简单，因为数据存储是少量方式可以选择。

javascript 中有四种基本的数据访问位置：
- 直接量：包括字符串、数字、布尔值、对象、数组、函数、正则表达式，具有特殊意义的空值（null）以及未定义（undefined）
- 变量：var 关键字创建
- 数组：具有数字索引
- 对象：具有字符串索引

大多数情况下，对一个直接量和一个局部变量数据访问的性能差异是微不足道的。访问数组和对象的代价要更高一些，具体差距多少依赖于浏览器。

## 管理作用域

作用域概念是理解javascript的关键，不仅从性能的角度而且从功能的角度。作用域对javascript有许多影响，从确定那些变量可以被函数访问，到确定this的值。作用域也关系到性能。

每一个javascript函数都可以看作一个对象，换一句话说它是一个函数实例。函数对象和其他对象一样，有可以访问的属性和一系列不能被访问的仅供javascript引擎使用的内部属性，其中一个内部属性是 `scope`。

`scope`属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定那些数据可以被函数访问。函数作用域链中的每一个对象被称为一个可变对象，每一个可变对象都以 `key/value` 的形式存在。当一个函数被创建之后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可以访问的对象。

例子：
```
function add(num1, num2){
var sum = num1 + num2;
return sum;
}
```

`add` 函数创建后，它的作用域链中填入一个单独可变对象，这个对象代表了所有全局范围定义的变量。（也就是提供了一个接口来访问全局定义的变量）

在调用函数的时候会建立一个内部对象，称为运行时上下文。一个运行时上下文定义了一个函数运行时的环境。函数每次调用，都会创建不同的运行时上下文，所以多次调用同一个函数就会导致多次创建运行时上下文。当函数执行完毕，运行时上下文就会被销毁。

一个运行时上下文有自己的作用域链，用于标识符解析。当运行时上下文被创建的时候，它的作用域链被初始化。在函数运行过程中，每遇到一个变量，标识符识别过程决定从哪里获得或者存储数据，此过程搜索运行时上下文的作用域链，查找同名标识符。这种搜索过程往往会影响性能。

标识符的位置越深，读写速度越慢，所以局部变量的速度总是最快的，全局变量的速度通常是最慢的。（全局变量总是位于作用域链的最后一个位置，不过好像chrome浏览器都差不多，因为v8的优化很好）

所以在没有优化javascript引擎的浏览器中，尽可能的使用局部变量。

一般来说，一个运行时上下文的作用域链不会被改变，但是有两种方法可以临时改变：
- with 关键字，最好不要使用影响性能
- catch 子句 最好不要在子句内访问局部变量

## 动态作用域
无论是 with 还是 catch 子句还有包含 `()` 的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（代码结构）来确定是否存在动态作用域。

例子：
```
function execute(code) {
(code);
function subroutine(){
return window;
}
var w = subroutine();
//what value is w?
};
```

大多数情况下，w将等价于全局window对象，不过在 `execute("var window={};")` 的情况下，会在函数中创建一个局部的window变量，所以不允许这段代码是没有办法预先确定标识符的确切含义的。

所以在绝对必要的时候才推荐使用动态作用域。

## 闭包、作用域、内存
通常一个函数的激活对象和运行时上下文一同被销毁，但是涉及闭包的时候，激活对象就无法被销毁，因为引用依然存在于闭包的属性中，这意味着脚本中的闭包和非闭包函数相比，需要更多的内存开销，特别是在大型网页应用中，这会是一个严重的问题，同时还有可能导致内存泄漏的问题。

脚本中最好小心的使用闭包。

## 对象成员
大多数javascript代码以面向对象的形式编写，因此存在很多对象成员访问。

对象成员包括属性和方法，在javascript中，两者差别甚微，对象的一个命名成员可以包含任何数据类型，既然函数也是一种对象，那么也可以包含一个函数，当一个命名成员引用了一个函数时，它被称为一个 `方法`，而一个非函数类型的数据则被称为 `属性`。

对象成员比直接量或局部变量的访问速度要慢，在某些浏览器上甚至比数组还要慢，其中的原因就是javascript中的对象的性质决定的。

### 原形

javascript中的对象是基于原形的，原形是其他对象的基础，定义并实现一个新对象必须具有的成员。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。

一个对象通过一个内部属性绑定到它的原形，开发人员可以通过 `chrome` | `firefox` | `safari`浏览器看到 `__proto__`。任何时候你创建一个内置类型的实例，这些实例自动拥有一个 `object` 作为它们的原形。

因此，对象可以有两种类型的成员：
- 实例成员：存在于实例本身
- 原形成员：从对象原形继承

### 原形链
对象的原形决定了一个实例的类型，默认情况下，所有对象都是object的实例，并继承了所有基本方法。

例子：
```
function Book(title, publisher){
this.title = title;
this.publisher = publisher;
}
Book.prototype.sayTitle = function(){
alert(this.title);
};
var book1 = new Book("High Performance JavaScript", "Yahoo! Press");
var book2 = new Book("JavaScript: The Good Parts", "Yahoo! Press");
alert(book1 instanceof Book); //true
alert(book1 instanceof Object); //true
book1.sayTitle(); //"High Performance JavaScript"
alert(book1.toString()); //"[object Object]"
```

Book 构造器用于创建一个新的实例
```
book1.__proto__ = Book.prototype 
Book.prototype.__proto = Object.prototype
Object.prototype.__proto = null
```

上面就是一个原型链，原型链的深度越深，搜索的速度就会越慢。

所以，如果要多次访问同一个对象的属性，最好把它存储到一个局部变量，用局部变量代替多余的属性查找带来的性能开销。特别是在处理嵌套对象成员的时候，它们会对运行速度产生难以置信的影响。

## 总结
- 直接量和局部变量的访问速度非常快，数组和对象需要更长的时间
- 局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环
- 避免使用改变运行时的作用域链
- 嵌套对象成员会造成重大性能影响，尽量少用
- 一个属性或方法在原型链中的位置越深，访问它的速度就越慢
- 将经常使用的对象成员、数组项、域外变量存入局部变量中，可以提高代码的性能

---

# 文档对象模型编程

对DOM操作的代价昂贵，通常是一个性能瓶颈。主要有三个方面：
- 访问和修改DOM元素
- 修改DOM元素的样式，造成重绘和重新排版
- 通过DOM事件处理用户响应

## DOM为什么会慢？
DOM和javascript实现保持相互独立。两个独立的部分通过功能接口连接就会带来性能损耗。

DOM是一个岛，javascript是一个岛，每次javascript访问DOM需要过桥，交一次过桥费，所以操作DOM次数越多，费用就越高。

## DOM 访问和修改
访问DOM就是交一次过桥费，修改DOM的费用可能更高，因为它可能导致浏览器重新计算页面变化。

最坏情况是使用在循环中执行这些操作。

### innerHTML和DOM方法

两者性能差距不大，不过在老式浏览器中，innerHTML速度更快一点，在最新的基于WebKit的浏览器（chrome和Safari）正相反。

### 节点克隆

使用DOM方法更新页面内容的另一个途径是克隆节点 ——— `element.cloneNode()` 代替 `document.createElement()`

在大多数浏览器中，克隆节点更有效率，但是提高不多：
- IE8 快2% IE6 和 IE7 没有变化
- Firefox 3.5 和 Safari 4 快了5.5%
- opera 快了 6%
- chrome2 快了10% chrome3 快了3%

### HTML集合
HTML 集合实际上在查询文档，当你更新信息时，每次都要重复执行这种查询操作。例如读取集合中元素的数目（也就是集合的length）。这正是低效率的来源。

例子：
```
var alldivs = document.getElementsByTagName_r('div');
for (var i = 0; i < alldivs.length; i++) {
document.body.appendChild(document.createElement('div'))
}
```
这段代码看上去只是简单地倍增了页面中div 元素的数量。它遍历现有div，每次创建一个新的div 并附加到body 上面。但实际上这是个死循环，因为循环终止条件alldivs.length 在每次迭代中都会增加，它反映出底层文档的当前状态。

像这样遍历HTML 集合会导致逻辑错误，而且也很慢，因为每次迭代都进行查询。

优化的办法很简单，只要将集合的length 属性缓存到一个变量中，然后在循环判断条件中使用这个变量。

## DOM API

你经常需要从一个DOM 元素开始，操作周围的元素，或者递归迭代所有的子节点。你可以使用childNode集合或者使用nextSibling 获得每个元素的兄弟节点。
在不同浏览器上，这两种方法的运行时间基本相等。但是在IE 中，nextSibling 表现得比childNode 好。在IE6 中，nextSibling 比对手快16 倍，而在IE7 中快105 倍。鉴于这些结果，在老的IE 中性能严苛的使用条件下，用nextSibling 抓取DOM 是首选方法。在其他情况下，主要看个人和团队偏好。

## 重绘和重排版

当浏览器下载完成所有页面html标记、javascript、css、图片之后，会解析文件并且创建两个内部数据结构：
- DOM 树：表示页面结构
- 渲染树：表示DOM节点如何显示

渲染树中为每个需要显示的DOM树节点存放至少一个节点（隐藏的DOM元素在渲染树中没有对应节点）。渲染树上的节点称为框或者盒，符合css模型定义，将页面元素看成一个具有填充、边距、边框和位置的盒。一旦DOM树和渲染树构造完毕，浏览器就可以显示（绘制）页面上的元素了。

当DOM改变影响到元素的几何属性导致其他元素的几何属性和位置受到影响，浏览器使渲染树上受到影响的部分失效，然后重构渲染树。这个过程称为重排版。重排版完成时，浏览器在一个重绘进程中重新绘制屏幕上受影响的部分。

不是所有的DOM 改变都会影响几何属性。例如，改变一个元素的背景颜色不会影响它的宽度或高度。在这种情况下，只需要重绘（不需要重排版），因为元素的布局没有改变。

重绘和重排版是负担很重的操作，可能导致网页应用的用户界面失去相应。所以，十分有必要尽可能减少这类事情的发生。

### 重排版
当布局和几何改变时需要重排版。在下述情况中会发生重排版：
- 添加或删除可见的DOM 元素
- 元素位置改变
- 元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）
- 内容改变，例如，文本改变或图片被另一个不同尺寸的所替代
- 最初的页面渲染
- 浏览器窗口改变尺寸

根据改变的性质，渲染树上或大或小的一部分需要重新计算。某些改变可导致重排版整个页面：例如，当一个滚动条出现时。

### 查询并刷新渲染树改变

因为计算量与每次重排版有关，大多数浏览器通过队列化修改和批量显示优化重排版过程。然而，你可能（经常不由自主地）强迫队列刷新并要求所有计划改变的部分立刻应用。获取布局信息的操作将导致刷新队列动作，这意味着使用了下面这些方法：
- offsetTop, offsetLeft, offsetWidth, offsetHeight
- scrollTop, scrollLeft, scrollWidth, scrollHeight
- clientTop, clientLeft, clientWidth, clientHeight
- getComputedStyle()

布局信息由这些属性和方法返回最新的数据，所以浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值。

在改变风格的过程中，最好不要使用前面列出的那些属性。任何一个访问都将刷新渲染队列，即使你正在获取那些最近未发生改变的或者与最新的改变无关的布局信息。

### 最小化重绘和重排版
重排版和重绘代价昂贵，所以，提高程序响应速度一个好策略是减少此类操作发生的机会。为减少发生次数，你应该将多个DOM 和风格改变合并到一个批次中一次性执行。

### 缓冲布局信息

浏览器通过队列化修改和批量运行的方法，尽量减少重排版次数。当你查询布局信息如偏移量、滚动条位置，或风格属性时，浏览器刷队列并执行所有修改操作，以返回最新的数值。最好是尽量减少对布局信息的查询次数，查询时将它赋给局部变量，并用局部变量参与计算。

### 将元素提出动画流
显示和隐藏部分页面构成展开/折叠动画是一种常见的交互模式。它通常包括区域扩大的几何动画，将页面其他部分推向下方。
重排版有时只影响渲染树的一小部分，但也可以影响很大的一部分，甚至整个渲染树。浏览器需要重排版的部分越小，应用程序的响应速度就越快。所以当一个页面顶部的动画推移了差不多整个页面时，将引发巨大的重排版动作，使用户感到动画卡顿。渲染树的大多数节点需要被重新计算，它变得更糟糕。

使用以下步骤可以避免对大部分页面进行重排版：
- 使用绝对坐标定位页面动画的元素，使它位于页面布局流之外。
- 启动元素动画。当它扩大时，它临时覆盖部分页面。这是一个重绘过程，但只影响页面的一小部分，避免重排版并重绘一大块页面。
- 当动画结束时，重新定位，从而只一次下移文档其他元素的位置。

> 译者注：文字描述比较简单概要，我对这三步的理解如下：
>1. 页面顶部可以“折叠/展开”的元素称作“动画元素”，用绝对坐标对它进行定位，当它的尺寸改变时，就
不会推移页面中其他元素的位置，而只是覆盖其他元素。
>2. 展开动作只在“动画元素”上进行。这时其他元素的坐标并没有改变，换句话说，其他元素并没有因为“动
画元素”的扩大而随之下移，而是任由动画元素覆盖。
>3. “动画元素”的动画结束时，将其他元素的位置下移到动画元素下方，界面“跳”了一下。

## 事件托管
当页面中存在大量元素，而且每个元素有一个或多个事件句柄与之挂接（例如onclick）时，可能会影响性能。连接每个句柄都是有代价的，无论其形式是加重了页面负担（更多的页面标记和JavaScript 代码）还是表现在运行期的运行时间上。你需要访问和修改更多的DOM 节点，程序就会更慢，特别是因为事件挂接过程都发生在onload（或DOMContentReady）事件中，对任何一个富交互网页来说那都是一个繁忙的时间段。挂接事件占用了处理时间，另外，浏览器需要保存每个句柄的记录，占用更多内存。当这些工作结束时，这些事件句柄中的相当一部分根本不需要（因为并不是100%的按钮或者链接都会被用户点到），所以很多工作都是不必要的。


一个简单而优雅的处理DOM 事件的技术是事件托管。它基于这样一个事实：事件逐层冒泡总能被父元素捕获。采用事件托管技术之后，你只需要在一个包装元素上挂接一个句柄，用于处理子元素发生的所有事件。

根据DOM 标准，每个事件有三个阶段：
- 捕获
- 到达目标
- 冒泡


例子：
```
<html>
	<head>
		<body>
			<div>
				<ul id='menu'>
					<li>
						<a href="menu1.html">menu1 #1</a>
					</li>
					<li></li>
					<li></li>
				</ul>
			</div>
		</body>
	</head>
</html>
```

当用户点击了 `menu1 #1` 链接，点击事件首先被 `<a>` 元素收到，然后沿着DOM树冒泡，被 `<li>` 元素收到，然后是 `<ul>` ，接着是 `<div>` 等等，一直到达文档的顶层，甚至WINDOW，这使得你可以只在父元素上挂接一个事件句柄，来接收所有子元素产生的事件通知。

事件托管技术并不复杂，你只需要监听事件，看看他们是不是从你感兴趣的元素中发出的。这里有一些冗余的跨浏览器代码，如果你将它们移入一个可重用的库中，代码就变得相当干净。跨浏览器部分包括：
- 访问事件对象，判断事件源
- 结束文档树上的冒泡
- 阻止默认动作

## 总结

DOM 访问和操作是现代网页应用中很重要的一部分。但每次你通过桥梁从ECMAScript 岛到达DOM 岛时，都会被收取“过桥费”。为减少DOM 编程中的性能损失，请牢记以下几点：
- 最小化DOM 访问，在JavaScript 端做尽可能多的事情
- 在反复访问的地方使用局部变量存放DOM 引用
- 小心地处理HTML 集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中
- 如果可能的话，使用速度更快的API，诸如querySelectorAll()和firstElementChild
- 注意重绘和重排版；批量修改风格，离线操作DOM 树，缓存并减少对布局信息的访问
- 动画中使用绝对坐标，使用拖放代理
- 使用事件托管技术最小化事件句柄数量

---

# 算法和流程控制
代码整体结构是执行速度的决定因素之一。代码量少不一定运行速度快，代码量多也不一定运行速度慢。性能损失与代码组织方式和具体问题解决办法直接相关。

## 循环
循环的类型：
- `for` 大概是最常用的循环结构，由四个部分组成：初始化体、前测条件、后执行体、循环体
```
for(初始化体;前测条件;后执行体){
  循环体
}
```
- `while` 是一个简单的预测试循环，由一个预测试条件和一个循环体构成
```
while(预测试条件){
  循环体
}
```
- `do while` 循环中，循环体至少运行一次，后测试条件决定循环体是否应再次执行
```
do{
  循环体
}while(后测试条件)
```
- `for-in` 用来枚举任何对象的命名属性，每次循环执行，属性变量被填充以对象属性的名字（一个字符串），直到所有的对象属性遍历完成才返回。返回的属性包括对象的实例属性和它从原型链继承而来的属性。
```
for(var a in onject){
  循环体
}
```

### 循环性能

在javascript的四种循环类型中，只有`for-in`循环明显要慢。

由于每次迭代操作要搜索实例或原形的属性，for-in 循环每次迭代都要付出更多开销，所以比其他类型循环慢一些。在同样的循环迭代操作中，for-in 循环比其他类型的循环慢7 倍之多。因此推荐的做法如下：除非你需要对数目不详的对象属性进行操作，否则避免使用for-in 循环。

除for-in 循环外，其他循环类型性能相当，难以确定哪种循环更快。选择循环类型应基于需求而不是性能。
如果循环类型与性能无关，那么如何选择？其实只有两个因素：
- 每次迭代做什么
- 迭代的次数

通过减少两者中的一个或者全部，都可以积极的影响循环的整体性能。

#### 减少迭代的工作量

不言而喻，如果一次循环迭代需要较长时间来执行，那么多次循环将需要更长时间。限制在循环体内进行耗时操作的数量是一个加快循环的好方法。

优化循环工作量的第一步是减少对象成员和数组项查找的次数。在大多数浏览器上，这些操作比访问局部变量或直接量需要更长时间。前面的例子中每次循环都查找items.length。这是一种浪费，因为该值在循环体执行过程中不会改变，因此产生了不必要的性能损失。你可以简单地将此值存入一个局部变量中，在控制条件中使用这个局部变量，从而提高了循环性能。
（chrome里面用局部变量代替length效率没什么提升甚至会降低效率，这个似乎在v8中自动优化了）

你还可以通过改变他们的顺序提高循环性能。通常，数组元素的处理顺序与任务无关，你可以从最后一个开始，直到处理完第一个元素。倒序循环是编程语言中常用的性能优化方法，但一般来说不太容易理解。在JavaScript 中，倒序循环可以略微提高循环性能，只要你消除因此而产生的额外操作。
（倒序循环也没发现性能提升）

#### 减少迭代次数
即使循环体中最快的代码，累计迭代上千次（也将是不小的负担）。此外，每次运行循环体时都会产生一个很小的性能开销，也会增加总的运行时间。减少循环的迭代次数可获得显著的性能提升。最广为人知的限制循环迭代次数的模式称作“达夫设备”。
达夫设备是一个循环体展开技术，在一次迭代中实际上执行了多次迭代操作。Jeff Greenberg 被认为是将达夫循环从原始的C 实现移植到JavaScript 中的第一人。一个典型的实现如下：
```
var iterations = Math.floor(items.length / 8),
startAt = items.length % 8,
i = 0;
do {
switch(startAt){
case 0: process(items[i++]);
case 7: process(items[i++]);
case 6: process(items[i++]);
case 5: process(items[i++]);
case 4: process(items[i++]);
case 3: process(items[i++]);
case 2: process(items[i++]);
case 1: process(items[i++]);
}
startAt = 0;
} while (--iterations);
```

达夫设备背后的基本理念是：每次循环中最多可8 次调用process()函数。循环迭代次数为元素总数除以8。因为总数不一定是8 的整数倍，所以startAt 变量存放余数，指出第一次循环中应当执行多少次process()。比方说现在有12 个元素，那么第一次循环将调用process()4 次，第二次循环调用process()8 次，用2 次循环代替了12 次循环。

是否值得使用达夫设备，无论是原始的版本还是修改后的版本，很大程度上依赖于迭代的次数。如果循环迭代次数少于1'000 次，你可能只看到它与普通循环相比只有微不足道的性能提升。如果迭代次数超过1'000 次，达夫设备的效率将明显提升。例如500'000 次迭代中，运行时间比普通循环减少到70%。

## 总结
- for，while，do-while 循环的性能特性相似，谁也不比谁更快或更慢
- 除非你要迭代遍历一个属性未知的对象，否则不要使用for-in 循环
- 改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数
- 一般来说，switch 总是比if-else 更快，但并不总是最好的解决方法
- 当判断条件较多时，查表法比if-else 或者switch 更快
- 浏览器的调用栈尺寸限制了递归算法在JavaScript 中的应用；栈溢出错误导致其他代码也不能正常执行
- 如果你遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法可以避免重复工作
- 运行的代码总量越大，使用这些策略所带来的性能提升就越明显


---

# 字符串和正则表达式


## 字符串连接

字符串连接可能对性能造成很大影响。通常一个任务通过一个循环，想字符串末尾不断地添加内容，来创建一个字符串，但此类处理在一些浏览器上表现的糟糕。

首先有多种方法可以合并字符串：
```
str="a"+"b"
str+="a"
str=["a","b"].join("")
str=str.concat("a","b")
```

当连接少量字符串的时候，所有的方法都很快，这时候可以选择最熟悉的。当合并的字符串长度和数量增加到一定程度的时候，它们之间的性能差异就开始显现了。

`+` 和 `+=` ：这些操作符提供了连接字符串的最简单方法，实际上，除了ie7和它之前的所有现代浏览器都对此优化的很好。不过还是有一些技术可以最大限度的提高这些操作的效率。

例子：
```
str+="a"+"b"
```
此代码执行会创建一个临时字符串 'ab' 然后再将临时字符串和 str 进行连接。
我们可以通过下面的：
```
str+='a'
str+='b'
```
来避免临时字符串的生成，这样在大多数浏览器上可以加快10%-40%
实际上可以用一行代码实现上面的性能提升：
`str=str+'a'+'b'`

如果在一个循环中，基本字符串位于最左端，这样就可以避免多次复制一个越来越大的基本字符串。


在赋值表达式中所有字符串连接都属于编译期常量，Firefox 自动地在编译过程中合并它们。当字符串是这样合并在一起时，由于运行时没有中间字符串，所以连接它们的时间和内存可以减少到零。这种功能非常了不起，但它并不经常起作用，因为通常从运行期数据创建字符串而不是从编译期常量。
（**经过测试发现：在chrome中第一种时间最短，第二种比第三种略快一点点，应该是v8引擎优化造成，在chrome浏览器上开发还是使用最简洁的语句为好，可能是对常用语法进行了优化**）

## 数组连接

在大多数浏览器上，数组连接比字符串的其他方法更慢，但是事实上，作为一种补偿方法，在ie7和更早的浏览器上它是连接大量字符串唯一高效的途径。

## 正则表达式

正则表达式的工作流程：
1. 编译
2. 设置起始位置
3. 开始匹配
4. 匹配成功或失败

在大多数现代正则表达式实现中，回溯是匹配过程的基本组成部分，然而回溯的计算代价昂贵，减少使用频率可能是编写高效正则表达式的关键。

## 总结

- 密集的字符串操作和正则表达式可能会成为性能障碍
- 连接数量巨大或者尺寸巨大的字符串，数组联合（concat）是ie7以及更早版本的浏览器的唯一有效方法
- 如果是其他版本的浏览器，数组联合可能是最慢的方法之一，直接使用 `+` 或者 `+=` 
- 回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因
- 回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯
- 正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串


---

# 响应接口

大多数浏览器只有一个单独的处理进程，由两个任务共享：javascript任务和用户界面更新任务。每个时刻只有一个操作可以执行，也就是说在javascript代码运行时用户界面不能对输入产生反应，反之亦然。

## UI线程

javascript和UI更新共享的进程通常被称为浏览器的UI线程。此线程围绕一个简单的队列系统工作，任务被保存到队列中直至进程空闲，一旦空闲队列中的下一个任务将被检索和运行。这些任务不是执行javascript代码就是执行UI更新，包括重绘和重排版。

也就是说javascript任务必须尽快结束，以免对用户体验造成不良影响。

浏览器在javascript运行时间上采取了限制，确保恶意代码编写者不能通过无尽的密集操作锁定用户浏览器或计算机，此类限制有两个：调用栈尺寸限制和长时间脚本限制。当一个脚本的运行时间达到一定限度就会被浏览器终止，同时会向用户显示一个对话框提示。

浏览器有两种方法测量脚本的运行时间：
- 统计自脚本开始运行以来执行了多少条语句。此方法意味着脚本在不同的机器上可能会运行不同的时间长度，可用内存和CPU速度可以影响一条独立语句运行所花费的时间
- 统计脚本运行的总时间。在特定时间内可运行的脚本数量和用户机器性能差异而不同，但脚本总是在固定的时间上被终止

不同浏览器的限制：
- IE 设置默认限制500万条语句，限制放在注册表中
- firefox 默认限制为10秒，存放在浏览器配置中
- Safari 默认限制为5秒
- chrome 没有独立的长运行脚本限制，而是依赖通用崩溃检测系统来处理此类实例
- opera 没有长运行脚本限制

当浏览器的长时间脚本限制被触发，有一个对话框显示给用户，而不管页面上的任何其他错误处理代码，这是一个主要的可用性问题，因为大多数互联网用户并不精通技术，会被错误信息所迷惑，不知道该停止脚本或允许它继续运行。

从开发者的观点看，没有办法改变长运行脚本对话框的外观，所以最好的办法就是避免长运行脚本。

一个单一的javascript操作应当使用的总时间应该是100毫秒，如果超过100毫秒，用户会认为自己和接口断开了。

有些时候一些javascript任务因为复杂性原因不能在100毫秒以内完成，这种情况下理想的方法是让出UI线程控制，所以我们需要定时器。

### 定时器

定时器代码复位所有相关浏览器限制，包括长运行脚本时间以及调用栈，这一特性使得定时器成为长运行javascript代码理想的跨浏览器解决方案。

javascript 定时器延时往往不准确，快慢大约几毫秒。windows 系统上定时器分辨率为15毫秒，也就是说一个值为15的定时器延时将根据最后一次系统时间刷新而转换为 0 或者 15。设置定时器延时小于 15 将在ie中导致浏览器锁定，所以最小值建议大于15毫秒。

### 分解任务
我们通常将一个任务分解成一系列子任务。如果一个函数运行时间太长，那么查看它是否可以分解成一系列能够短时间完成的较小的函数。可将一行代码简单地看作一个原子任务，多行代码组合在一起构成一个独立任务。某些函数可基于函数调用进行拆分。

如果函数运行时间太长，它可以拆分成一系列更小的步骤，把独立方法放在定时器中调用。你可以将每个函数都放入一个数组，然后使用前一节中提到的数组处理模式。


## 网页工人线程（web workers）

网页工人线程对网页应用来说是一个潜在的巨大性能提升，因为新的工人线程在自己的线程中运行javascript，这意味着工人线程中的代码运行不仅不会影响到浏览器的UI，而且也不会影响其他工人线程中运行的代码。

由于网页工人线程不绑定UI线程，也意味着它们不能访问许多浏览器资源。每个工人线程都有自己的全局运行环境，只有javascript特性的一个子集可用，由下面部分组成：
- 一个浏览器对象，包括四个属性：appName,appVersion,userAgent,platform
- 一个 location 对象
- 一个 self 对象指向全局工人线程对象
- 一个 importScript() 方法，使得工人线程可以加载外部javascript 文件
- 所有javascript对象
- xmlhttprequest 构造器
- settimeout 和 setInterval
- close() 方法结束工人线程


网页工人线程有不同的全局环境，必须要创建一个完全独立的javascript文件，包含那些在工人线程中运行的代码，要创建工人线程，必须要传入这个文件的URL：
```
var worker = new Worker("code.js")
```
此代码一旦执行，将为指定文件创建一个新县城和一个新的工人线程运行环境，此文件被异步下载，下载运行完成后才启动工人线程。

### 工人线程交互

工人线程和网页代码通过事件接口进行交互，网页代码可通过 postMessage() 方法向工人线程传递数据。工人线程中有 onmessage 事件句柄用于接收信息：
```
var worker = new Worker("code.js");
worker.onmessage = function(event){
alert(event.data);
};
worker.postMessage("Nicholas");
```
消息系统是页面和工人线程之间唯一的交互途径。

当工人线程通过importScripts()方法加载外部JavaScript 文件，它接收一个或多个URL 参数，指出要加载的JavaScript 文件网址。工人线程以阻塞方式调用importScripts()，直到所有文件加载完成并执行之后，脚本才继续运行。由于工人线程在UI 线程之外运行，这种阻塞不会影响UI 响应

### 用途

网页工人线程适合于那些纯数据的，或者与浏览器UI 没关系的长运行脚本。它看起来用处不大，而网页应用程序中通常有一些数据处理功能将受益于工人线程，而不是定时器。

可能受益的任务：
- 编码、解码一个大字符串
- 负责的数学运算
- 给一个大数组排序

## 总结

- JavaScript 运行时间不应该超过100 毫秒。过长的运行时间导致UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响
- JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节
- 定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务
- 网页工人线程是新式浏览器才支持的特性，它允许你在UI 线程之外运行JavaScript 代码而避免锁定UI
- 网页应用程序越复杂，积极主动地管理UI 线程就越显得重要。没有什么JavaScript 代码可以重要到允许影响用户体验的程度

---

# ajax/xml

##  数据传输

### 请求数据

有五种常用技术用于向服务器请求数据：
- xmlHttpRequest (XHR)
- 动态脚本标签插入
- iframes
- Comet
- Multipart XHR

现在常用的是 XHR、动态脚本标签插入、Multipart XHR，其余的往往是极限情况使用。

目前最常用的方法是 XHR 。

#### XHR
当使用XHR 请求数据时，你可以选择POST 或GET。如果请求不改变服务器状态只是取回数据（又称作幂等动作）则使用GET。GET 请求被缓冲起来，如果你多次提取相同的数据可提高性能。只有当URL 和参数的长度超过了2'048 个字符时才使用POST 提取数据。因为Internet Explorer 限制URL的长度，过长将导致请求（参数）被截断。

#### 动态脚本标签插入
该技术克服了XHR 的最大限制：它可以从不同域的服务器上获取数据。这是一种黑客技术，而不是实例化一个专用对象，你用JavaScript 创建了一个新脚本标签，并将它的源属性设置为一个指向不同域的URL。

例子：
```
var scriptElement = document.createElement('script');
scriptElement.src = 'http://any-domain.com/javascript/lib.js';
document.getElementsByTagName_r('head')[0].appendChild(scriptElement);
```

但是动态脚本标签插入与XHR 相比只提供更少的控制。你不能通过请求发送信息头。参数只能通过GET方法传递，不能用POST。你不能设置请求的超时或重试，实际上，你不需要知道它是否失败了。你必须等待所有数据返回之后才可以访问它们。你不能访问响应信息头或者像访问字符串那样访问整个响应报文。

最后一点非常重要。因为响应报文被用作脚本标签的源码，它必须是可执行的JavaScript。你不能使用裸XML，或者裸JSON，任何数据，无论什么格式，必须在一个回调函数之中被组装起来。

#### Multipart XHR

多部分XHR（MXHR）允许你只用一个HTTP 请求就可以从服务器端获取多个资源。它通过将资源（可以是CSS 文件，HTML 片段，JavaScript 代码，或base64 编码的图片）打包成一个由特定分隔符界定的大字符串，从服务器端发送到客户端。JavaScript 代码处理此长字符串，根据它的媒体类型和其他“信息头”解析出每个资源。

使用此技术有一些缺点，其中最大的缺点是以此方法获得的资源不能被浏览器缓存。如果你使用MXHR获取一个特定的CSS 文件然后在下一个页面中正常加载它，它不在缓存中。因为整批资源是作为一个长字符串传输的，然后由JavaScript 代码分割。由于没有办法用程序将文件放入浏览器缓存中，所以用这种方法获取的资源也无法存放在那里。

## 数据格式

- XML 标准 速度慢
- JSON 
- html

## 总结

- 高性能Ajax 包括：知道你项目的具体需求，选择正确的数据格式和与之相配的传输技术
- 作为数据格式，纯文本和HTML 是高度限制的，但它们可节省客户端的CPU 周期。XML 被广泛应用普遍支持，但它非常冗长且解析缓慢。JSON 是轻量级的，解析迅速（作为本地代码而不是字符串），交互性与XML 相当。字符分隔的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的
程序在服务器端构造格式，并在客户端解析
- 减少请求数量，可通过JavaScript 和CSS 文件打包，或者使用MXHR
- 缩短页面的加载时间，在页面其它内容加载之后，使用Ajax 获取少量重要文件
- 确保代码错误不要直接显示给用户，并在服务器端处理错误

